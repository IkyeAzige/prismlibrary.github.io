{
  "articles/Xamarin-Forms/3-Navigation-Service.html": {
    "href": "articles/Xamarin-Forms/3-Navigation-Service.html",
    "title": "Using the Navigation Service | Prism",
    "keywords": "Using the Navigation Service Navigating in a Prism application is conceptually different than standard navigation in Xamarin.Forms. While Xamarin.Forms navigation relies on a Page class instance to navigate, Prism removes all dependencies on Page types to achieve loosely coupled navigation from within a ViewModel. In Prism, the concept of navigating to a View or navigating to a ViewModel does not exist. Instead, you simply navigate to an experience, or a unique identifier, which represents the target view you wish to navigate to in your application. Page navigation in Prism is accomplished by using the INavigationService . Getting the Navigation Service To obtain the INavigationService in your ViewModels simply ask for it as a constructor parameter. There is a caveat while injecting the Navigation Service into your ViewModels. The current version of the Prism.Forms library requires that you name the injection parameter precisely as navigationService . Otherwise the Navigation Service is unaware of the current View it is used on. This is a limitation of the dependency injection container. public MainPageViewModel(INavigationService navigationService) // has to be named correctly { _navigationService = navigationService; } Navigating Once you have the INavigationService in your ViewModel, you can navigate to your target views by calling the INavigationService.NavigateAsync method and provide the unique identifier/key that represents the target Page. _navigationService.NavigateAsync(\"MainPage\"); For more dynamic scenarios, or scenarios which involve navigating with Uris, you can use either a relative or an absolute Uri to navigate. //relative _navigationService.NavigateAsync(new Uri(\"MainPage\", UriKind.Relative)); //absolute _navigationService.NavigateAsync(new Uri(\"http://www.brianlagunas.com/MainPage\", UriKind.Absolute); Note: An absolute URI resets the navigation stack regardless of where you call it. It is equivalent to Application.Current.MainPage = new MainPage() Important: If you do not register your Pages with Prism, navigation will not work. Registering Registering your Page for navigation is essentially mapping a unique identifier/key to the target view during the bootstrapping process. In order to register your Pages for Navigation, override the RegisterTypes method in your Bootstrapper . Bootstrapper: protected override void RegisterTypes() { //register pages for navigation } Next, use the RegisterTypeForNavigation<T> extension method off of the current dependency injection container. There are three ways to register your Pages for navigation. Default Registration By default, RegisterTypeForNavigation will use the Name of the Page type as the unique identifier/key. The following code snippet results in a mapping between the MainPage type, and the unique identifier/key of \"MainPage\". This means when you request to navigate to the MainPage, you will provide the string \"MainPage\" as the navigation target. protected override void RegisterTypes() { Container.RegisterTypeForNavigation<MainPage>(); } To navigate to the MainPage using this registration method: _navigationService.NavigateAsync(\"MainPage\"); Custom Registration You can override this convention by providing a custom unique identifier/key as a method parameter. In this case, we are overriding the convention for MainPage, and are creating a mapping between the MainPage Page type, and the unique identifier/key of \"CustomKey\". So when we want to navigate to the MainPage, we would provide the \"CustomKey\" as the navigation target. protected override void RegisterTypes() { Container.RegisterTypeForNavigation<MainPage>(\"CustomKey\"); } To navigate to the MainPage using this registration method: _navigationService.NavigateAsync(\"CustomKey\"); GoBackAsync Going back to the previous View is as simple calling the INavigationService.GoBackAsync method. _navigationService.GoBackAsync(); Passing parameters The Prism navigation service also allows you to pass parameters to the target view during the navigation process. Passing parameters to the next View can be done using an overload of the INavigationService.NavigateAsync method. This overload accepts a NavigationParameters object that can be used to supply data to the next View. The NavigationParameters object is in fact just a dictionary. It can accept any arbitrary object as a value. var navigationParams = new NavigationParameters (); navigationParams.Add(\"model\", new Contact ()); _navigationService.NavigateAsync(\"MainPage\", navigationParams); You can also create an HTML query string to generate your parameter collection. var queryString = \"code=CR&desc=Red\"; var navigationParams = new NavigationParameters(queryString); _navigationService.NavigateAsync(\"MainPage\", navigationParameters); When using a Uri to navigate, you may append the Uri with parameters, which will be used as the navigation parameters. //query string _navigationService.NavigateAsync(new Uri(\"MainPage?id=3&name=brian\", UriKind.Relative)); //using NavigationParameters in Uri _navigationService.NavigateAsync(new Uri(\"MainPage\" + navParameters.ToString(), UriKind.Relative)); //using both Uri parameters and NavigationParameters var navParameters = new NavigationParameters (); navParameters.Add(\"name\", \"brian\"); _navigationService.NavigateAsync(new Uri(\"MainPage?id=3\", UriKind.Relative), navParameters); Getting to this data in the target View that is being navigated to, can be achieved by using the INavigationAware interface on the corresponding ViewModel. INavigationAware The ViewModel of the target navigation Page can participate in the navigation process by implementing the INavigationAware interface. This interface adds two methods to your ViewModel so you can intercept when the ViewModel is navigated to, or navigated away from. Example: public class ContactPageViewModel : INavigationAware { private Contact _contact; public void OnNavigatedTo(NavigationParameters parameters) { _contact = (Contact)parameters[\"model\"]; } public void OnNavigatedFrom(NavigationParameters parameters) { } } IConfirmNavigation A ViewModel can determine whether or not it can perform a navigation operation. When a ViewModel implements the IConfirmNavigation or the IConfirmNavigationAsync interface, the navigation process looks to see what the result of this method is. If true , a navigation process can be invoked, meaning a call to NavigationService.NavigateAsync(\"target\") can be made. If false , the ViewModel cannot invoke the navigation process. public class ContactPageViewModel : IConfirmNavigation { public bool CanNavigate(NavigationParameters parameters) { return true; } }"
  },
  "articles/Xamarin-Forms/2-ViewModelLocator.html": {
    "href": "articles/Xamarin-Forms/2-ViewModelLocator.html",
    "title": "Using the ViewModelLocator | Prism",
    "keywords": "Using the ViewModelLocator Prism for XF depends on the use of VML namespace attached property naming convention change naming convention changing resolver custom registrations maybe link to primary ViewModelLocator topic so we don't repeat content, and only include the namesapce and attached property info in this topic?"
  },
  "articles/Xamarin-Forms/1-Getting-Started.html": {
    "href": "articles/Xamarin-Forms/1-Getting-Started.html",
    "title": "Getting started with Prism for Xamarin.Forms | Prism",
    "keywords": "Getting started with Prism for Xamarin.Forms Content Overview Prerequisites Background Xamarin.Forms MVVM Creating a new solution Installing and using the Prism Template Pack Running the app Views overview View Models overview Adding a new Page (View) and ViewModel Navigating to your new Page Overview This guide will walk you through creating a new Xamarin.Forms project that uses Prism, running the application, and modifying it to demonstrate basic use of Prism for Xamarin.Forms. Prerequisites This guide assumes that you have Xamarin, Xamarin Android Player, and Visual Studio 2015 already installed along with a basic understanding of those technologies. If you do not, please take a look at the excellent resources available at xamarin.com and visualstudio.com . Background What's Xamarin.Forms? Build native UIs for iOS, Android and Windows from a single, shared C# codebase. Xamarin.Forms allows you to build applications for iOS, Android and Windows that share both back and front end code. For more information take a look at Xamarin.Forms . What's MVVM? MVVM stands for Model View ViewModel and it is a design pattern that allows for clean separation of concerns between the user interface and the model behind it. A major advantage of MVVM is that it leverages data-binding to display information and respond to user input. The following diagram shows the interaction between the components in MVVM. For more information reference The MVVM Pattern by Microsoft Patterns & Practices Creating a new solution Installing and using the Prism Template Pack The easiest way to get a new solution up and running is with the Prism Template Pack . Let's start by installing it in Visual Studio. Go to Tools > Extensions and Updates select Online and search for Prism Template Pack . Locate the the extensions, click Download , and complete the installation. Click the Restart Now button. Now that we have the Template Pack installed, lets create a new solution. Go to File > New > Project... select Installed > Templates > Visual C# > Prism . Here you will find all the templates available for a new Prism project/solution. Select Prism Unity App (Forms) Visual C# fill in the name of your project/solution and click OK A new solution was created with a Portable Class Library (PCL) project labeled (Portable) and device-dependent projects (Android, iOS, Windows Phone). NuGet packages were added to these projects for Xamarin.Forms, Prism, and Prism.Unity along with all their dependencies. Running the app Android Right click on the Android project and select set as startup project. Also ensure build and deploy are both checked for the Android project in the Configuration Manager. Open the Xamarin Android Player and ensure that a device image is installed and note the API level of the device image. Open the Android project properties and change the Minimum Android to target to be equal or less than the API level of the device image you will be running on. Select the Android Player device from the Debug drop down menu and click the debug play button (or press F5). iOS This is for Visual Studio (on Windows): First make sure that there's a connection with the Xamarin Mac Agent. Right click on the iOS project and select set as startup project. Also ensure build and deploy are both checked for the iOS project in the Configuration Manager. For running the application on a physical iOS device, there must be an connected the iOS device to the PC. The build configuration needs to be set on \"iPhone\" (even for testing with an iPad). If there is only one iOS device attached to the PC it'll select the one. When there're multiple iOS devices attached, you must select with device you want to run on. For running the application on a iOS simulator needs the build configuration be set to \"iPhoneSimulator\" (even for testing with an iPad simulator). After chosen the build configuration, the app can be run by click the debug play button (or press F5). Windows Phone To be added. Views Within the Portable project there is a View folder. This folder will contain all of your view related code. The template created a Content Page called MainPage.xaml in this folder. Lets take a look at this file. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism=\"clr-namespace:Prism.Mvvm;assembly=Prism.Forms\" prism:ViewModelLocator.AutowireViewModel=\"True\" x:Class=\"GettingStartedWithPrismForXamarinForms.Views.MainPage\" Title=\"MainPage\"> <StackLayout HorizontalOptions=\"Center\" VerticalOptions=\"Center\"> <Label Text=\"{Binding Title}\" /> </StackLayout> </ContentPage> There are some important things happening here, let's break down whats going on. xmlns:prism=\"clr-namespace:Prism.Mvvm;assembly=Prism.Forms\" The Prism library is referenced. prism:ViewModelLocator.AutowireViewModel=\"True\" This view (MainPage.xaml) is wired to the view model (MainPageViewModel.cs) automatically via naming conventions allowing for databinding to the view model. See ViewModelLocator documentation for more information. <Label Text=\"{Binding Title}\" /> A label is created on the page with the text bound to the property named Title in the view model (MainPageViewModel.cs). View Models Within the Portable project there is a ViewModels folder. This folder will contain all of your view model related code. The template created a view model for the MainPage called MainPageViewModel.cs in this folder. Lets take a look at this class and break down what is going on here. public class MainPageViewModel : BindableBase, INavigationAware { private string _title; public string Title { get { return _title; } set { SetProperty(ref _title, value); } } public void OnNavigatedFrom(NavigationParameters parameters){} public void OnNavigatedTo(NavigationParameters parameters) { if (parameters.ContainsKey(\"title\")) Title = (string)parameters[\"title\"] + \" and Prism\"; } } public class MainPageViewModel : BindableBase, INavigationAware The MainPageViewModel inherits from BindableBase and implements the INavigationAware interface. The BindableBase class implements the INotifyPropertyChanged interface which allows for the view to be able to databind to properties created here. BindableBase also provides a protected SetProperty method to simplify creating these properties. The INavigationAware interface allows for the view model to be notified when it is being navigated from or being navigated to. See the INavigationAware documentation for more information. private string _title; public string Title { get { return _title; } set { SetProperty(ref _title, value); } } Creates a public property named Title that triggers the OnPropertyChanged event when the value is set. public void OnNavigatedFrom(NavigationParameters parameters){} ... public void OnNavigatedTo(NavigationParameters parameters) { ... These methods are called with the view model is navigated from or to. Here it expects a string via the NavigationParameters parameter and modifies the Title property with the string's value. See the INavigationAware documentation for more information. Adding a new Page (View) and ViewModel Now that we have a basic understanding of how project is setup with Prism for Xamarin.Forms, let's add to it and create a new Page (View) and ViewModel. We'll create a page with a text entry field and a button similar to the wireframe below. Later we'll add functionality to make the phone speak the text that's entered into the text field. View Let's create the new content page in the project, also known as the view. Again, the easiest way to do this is with the Prism Template Pack . We'll create the view first. Right click on the Views folder, click Add > New Item... under Installed > Visual C# > Prism > Forms select Prism ContentPage (Forms) . Name the page SpeakPage.xaml and click Add . This creates a blank content page. There are many different types of pages available in Xamarin Forms , but the ContentPage is one of the most basic. It displays a single visual object, typically a layout . Update SpeakPage.xaml to have the contents shown below. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/\" xmlns:prism=\"clr-namespace:Prism.Mvvm;assembly=Prism.Forms\" prism:ViewModelLocator.AutowireViewModel=\"True\" x:Class=\"HelloXFPrism.Views.SpeakPage\"> <StackLayout VerticalOptions=\"CenterAndExpand\"> <Entry Text=\"{Binding TextToSay}\" /> <Button Text=\"Speak\" Command=\"{Binding SpeakCommand}\"/> </StackLayout> </ContentPage> Let's break down what is going on here. xmlns:prism=\"clr-namespace:Prism.Mvvm;assembly=Prism.Forms\" The Prism library is referenced. prism:ViewModelLocator.AutowireViewModel=\"True\" This view (SpeakPage.xaml) is wired to the view model (SpeakPageViewModel.cs) automatically via naming conventions allowing for databinding to the view model. See ViewModelLocator documentation for more information. <StackLayout VerticalOptions=\"CenterAndExpand\"> ... </StackLayout> This sets the ContentPage's view to a StackLayout . A StackLayout positions it's child elements each on a single line, stacking them either horizontally or vertically. This is a very common layout used within Xamarin Forms. We're using it along with it's VerticalOptions set to CenterAndExpand so the child elements show up as stacked vertically and centered as shown in the wireframe above. <Entry Text=\"{Binding TextToSay}\" /> An Entry is provided that allows the user to enter text. The text that is entered is data-bound to a property named TextToSay in the SpeakPageViewModel, which we'll create soon. <Button Text=\"Speak\" Command=\"{Binding SpeakCommand}\"/> A Button is placed below the Entry. The button's command is executed when it is clicked and is bound to a command named SpeakCommand in the SpeakPageViewModel, which we'll create soon. View Model Now that we have a view named SpeakPage, we'll add it's corresponding view model. As with all the other steps, the easiest way to create a view model is with the Prism Template Pack . Right click on the ViewModels folder, click Add > New Item... under Installed > Visual C# > Prism > Forms select Prism ViewModel . Name the page SpeakPageViewModel.cs and click Add . This creates a view model for the SpeakPage. Update SpeakPageViewModel.cs to have the following contents within the namespace. namespace HelloXFPrism.ViewModels { using Prism.Commands; using Prism.Mvvm; public class SpeakPageViewModel : BindableBase { private string _textToSay = \"Hello Prism\"; public string TextToSay { get { return _textToSay; } set { SetProperty(ref _textToSay, value); } } public DelegateCommand SpeakCommand { get; set; } public SpeakPageViewModel() { SpeakCommand = new DelegateCommand(Speak); } private void Speak() { //TODO: call service } } } Let's break down what is going on here. private string _textToSay = \"Hello Prism\"; public string TextToSay { get { return _textToSay; } set { SetProperty(ref _textToSay, value); } } Creates a string property that the text entry field is bound to. The initial text is \"Hello Prism\". SetProperty is provided by Prism to simplify creating bindable properties. See the ViewModels section of this document for more information. public DelegateCommand SpeakCommand { get; set; } public SpeakPageViewModel() { SpeakCommand = new DelegateCommand(Speak); } Creates a DelegateCommand called SpeakCommand that the Speak button is bound to. The SpeakCommand is created in the SpeakPageViewModel constructor and will invoke the Speak method, which hasn't been written yet. To be able to perform the actual text-to-speech platform specific APIs need to be used. This is outside the scope of this documentation, but head over to the Dependency Service documentation to see how this is done. Navigating to your new page We now have two pages in our app, a main page and a speak page. To navigate to the new page, we'll need to register the page for navigation. In the Portable Class Library, HelloXFPrism (Portable) , open App.xaml.cs (you may have to click the carrot next to App.xaml to see it). Register the new page for navigation by updating RegisterTypes() to include the following. Container.RegisterTypeForNavigation<SpeakPage>(); You can now navigate to the new page so let's setup MainPage to navigate. In MainPage.xaml add a button below the existing label. <Button Text=\"Navigate to speak page\" Command=\"{Binding NavigateToSpeakPageCommand}\" /> Now we need to update MainPage's view model to include the NavigateToSpeakPageCommand and perform navigation. Update MainPageViewModel.cs to include the following. private INavigationService _navigationService; public DelegateCommand NavigateToSpeakPageCommand { get; private set; } public MainPageViewModel(INavigationService navigationService) { _navigationService = navigationService; NavigateToSpeakPageCommand = new DelegateCommand(NavigateToSpeakPage); } private void NavigateToSpeakPage() { _navigationService.Navigate(\"SpeakPage\"); } Let's break down what's going on here. public MainPageViewModel(INavigationService navigationService) { _navigationService = navigationService; NavigateToSpeakPageCommand = new DelegateCommand(NavigateToSpeakPage); } Using dependency injection, gets the navigation service and also creates the NavigateToSpeakPageCommand. private void NavigateToSpeakPage() { _navigationService.NavigateAsync(\"SpeakPage\"); } Tells the navigation service to navigate to the SpeakPage. With navigation all wired up and the \"Navigate to speak page\" button is pressed in the view the NavigateToSpeakPageCommand will be called on the view model, the command will execute the NavigateToSpeakPage method, and finally the Navigation Service will perform the navigation to the SpeakPage. For more information on the navigation service see the navigation service documentation"
  },
  "articles/Getting-Started/NuGet-Packages.html": {
    "href": "articles/Getting-Started/NuGet-Packages.html",
    "title": "NuGet Packages | Prism",
    "keywords": "NuGet Packages Core Packages These are the base packages for each platform, together with the Prism's Core assembly as a cross-platform PCL. Platform Assembly Package Version PCL Prism.dll Prism.Core WPF Prism.Wpf.dll Prism.Wpf Xamarin.Forms Prism.Forms.dll Prism.Forms Windows 10 UWP Prism.Windows.dll Prism.Windows Container-specific packages Each supported IoC container has its own package assisting in the setup and usage of that container together with Prism. The assembly is named using this convention: Prism. Container.Platform .dll, e.g. Prism.Unity.Wpf.dll . Following matrix shows the platform specific support currently available. Package Version WPF Win10 UWP Xamarin.Forms Prism.Autofac (*) X X ↓ Prism.Autofac.Forms - - X Prism.DryIoc X - - Prism.DryIoc.Forms - - X Prism.Mef (**) X - - Prism.Ninject (*) X ↓ Prism.Ninject.Forms - - X Prism.StructureMap X Prism.Unity (*) X X ↓ Prism.Unity.Forms - - X (*) As Xamarin Forms also supports UWP now, adding Prism.Unity, Prism.Ninject, or Prism.Autofac puts in some incorrect dependencies. Therefore we created a new package for Xamarin Forms projects. (**) MEF is supported with WPF for compatibility with previous versions. It will not be added to Windows 10 UWP or Xamarin Forms. Note that adding the container-specific package to your project, will also pull in the correct platform-specific package and the core PCL library. E.g. when you'd like to use Unity in a WPF project, add the Prism.Unity package and the rest will be pulled in as well. Overview of assemblies To recapitulate the packages described above, this is the list of all assemblies added to your solution by Prism 6 depending on the container and platform used. Prism PCL Assembly Package Prism.dll Prism.Core WPF Assembly Package Prism.Wpf.dll Prism.Wpf Prism.Unity.Wpf.dll Prism.Unity Prism.Mef.Wpf.dll Prism.Mef Prism.Autofac.Wpf.dll Prism.Autofac Prism.StructureMap.Wpf.dll Prism.StructureMap Prism.Ninject.Wpf.dll Prism.Ninject Prism.DryIoc.Wpf.dll Prism.DryIoc Xamarin.Forms Assembly Package Prism.Forms.dll Prism.Forms Prism.Unity.Forms.dll Prism.Unity.Forms Prism.Ninject.Forms.dll Prism.Ninject.Forms Prism.Autofac.Forms.dll Prism.Autofac.Forms Prism.DryIoc.Forms.dll Prism.DryIoc.Forms Universal Windows Platform Assembly Package Prism.Windows.dll Prism.Windows Prism.Unity.Windows.dll Prism.Unity Prism.Autofac.Windows.dll Prism.Autofac"
  },
  "articles/Getting-Started/Assembly-Versioning.html": {
    "href": "articles/Getting-Started/Assembly-Versioning.html",
    "title": "Prism Assembly Versioning | Prism",
    "keywords": "Prism Assembly Versioning Assembly versioning is an important, and often ignored, aspect of a project. There are three assembly attributes defined in the AssemblyInfo.cs file of each project of Prism. These attribute are the AssemblyAttribute , the AssemblyFileAttribute , and the AssemblyInformationAttribute . [assembly: AssemblyVersion(\"1.0.0.0\")] [assembly: AssemblyFileVersion(\"1.0.0.0\")] [assembly: AssemblyInformationalVersion(\"1.0.0.0\")] By convention, the four parts of each version are referred to as the Major Version, Minor Version, Build , and Revision . This document decribes how Prism unitilizes each of these attributes to version its assemblies, and what numbering convention each attribute follows. AssemblyVersion The AssemblyVersion is used by the CLR to bind to strongly named assemblies. It is stored in the AssemblyDef manifest metadata table of the built assembly, and in the AssemblyRef table of any assembly that references it. When you reference a strongly named assembly, which Prism is strongly named, you are tightly bound to that specific AssemblyVersion of that assembly. For example; assume you referenced version 1.0.0.0 of an assembly and then built and released your application to your users. Then, an updated version of 1.0.2.0 which fixes a critical bug became available, and was dropped into the executing folder (possibly GAC) of your application. That binding would fail and your application would crash. You would have to reference the new 1.0.2.0 version and rebuild and redeploy your application. To avoid this, Prism has adopted the following format for the AssemblyVersion : [Major].[Minor] We will only update the AssemblyVersion when there is a major or minor change in the functionality of the assembly. We will not update the AssemblyVersion when releasing bug fixes and updates. AssemblyFileVersion The AssemblyFileVersion is intended to uniquely identify the build of an assembly. When patches and bug fixes are released, the AssemblyFileVersion is incremented to reflect those changes. Prism has standardized on the following format for AssemblyFileVersion : [Major].[Minor].[Revision] This will allow Prism to release bug fixes and updates without having to increment the AssemblyVersion . This enables you as a developer to patch your applications without having to re-reference Prism assemblies or recompile and re-release your application. AssemblyInformationVersion The AssemblyInformationalVersion is intended to allow coherent versioning of the entire product, which may consist of many assemblies that are independently versioned, and potentially developed by disparate teams. The AssemblyInformationAttribute is used to communicate to the community, or customers, what version of Prism is the current release. For example; Assume we release a product with an AssemblyInformationAttribute of 2.0.0.0. This product may be made up of many assemblies with their AssemblyVersion ranging from 1.0.0.0 to 1.9.9.9. Although the individual assemblies are not versioned at 2.0.0.0, the product itself is a 2.0 release. The AssemblyInformationAttribute lets us market Prism as an overall product made up of several related assemblies that have different assembly versions. Prism has standardize on the following format for AssemblyInformationVersioning : [Major].[Minor].[Revision] Note: This is the version that the Prism NuGet packages will match"
  },
  "articles/Xamarin-Forms/6-EventToCommandBehavior.html": {
    "href": "articles/Xamarin-Forms/6-EventToCommandBehavior.html",
    "title": "Using the EventToCommandBehavior | Prism",
    "keywords": "Using the EventToCommandBehavior The EventToCommandBehavior class provide a convenient way to, in XAML, \"bind\" events to ICommand according to MVVM paradigm to avoid code behind. Usage The EventToCommandBehavior expose the following properties EventName The name of the event to listen to. For example ItemTapped Command The ICommand that will be executed when the event is raised CommandParameter The parameter that will be sent to the ICommand.Execute(object) method EventArgsConverter Instance of IValueConverter that allows operating on the EventArgs type for the EventName EventArgsConverterParameter The parameter that will be sent as the parameter argument to IValueConverter.Convert method EventArgsParameterPath Parameter path to extract property from EventArgs that will be passed to ICommand.Execute(object) First declare the namespace and assembly in where EventToCommandBehavior is declared and declare a XML-namespace. xmlns:b=\"clr-namespace:Prism.Behaviors;assembly=Prism.Forms\" CommandParameter Bind or declare a parameter that will be sent to the ICommand.Execute(object) method. <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"MyNamespace.ContentPage\" xmlns:b=\"clr-namespace:Prism.Behaviors;assembly=Prism.Forms\"> <ListView> <ListView.Behaviors> <b:EventToCommandBehavior EventName=\"ItemTapped\" Command=\"{Binding ItemTappedCommand}\" CommandParameter=\"MyParameter\" /> </ListView.Behaviors> </ListView> </ContentPage> EventArgsConverter Using the EventArgsConverter to retrieve the ItemTappedEventArgs.Item property. using System; using System.Globalization; using Xamarin.Forms; namespace Prism.Converters { public class ItemTappedEventArgsConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { var itemTappedEventArgs = value as ItemTappedEventArgs; if (itemTappedEventArgs == null) { throw new ArgumentException(\"Expected value to be of type ItemTappedEventArgs\", nameof(value)); } return itemTappedEventArgs.Item; } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); } } } The XAML need a reference to the converter and the converter resource need to be defined <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"MyNamespace.ContentPage\" xmlns:b=\"clr-namespace:Prism.Behaviors;assembly=Prism.Forms\" xmlns:c=\"clr-namespace:Prism.Converters;assembly=Prism.Forms\"> <ContentPage.Resources> <ResourceDictionary> <c:ItemTappedEventArgsConverter x:Key=\"itemTappedEventArgsConverter\" /> </ResourceDictionary> </ContentPage.Resources> <ListView> <ListView.Behaviors> <b:EventToCommandBehavior EventName=\"ItemTapped\" Command=\"{Binding ItemTappedCommand}\" EventArgsConverter=\"{StaticResource itemTappedEventArgsConverter}\" /> </ListView.Behaviors> </ListView> </ContentPage> EventArgsParameterPath Attach the command to ItemTapped event will raise the itemTappedEventArgs event. public class ItemTappedEventArgs : EventArgs { public object Item { get; } public object Group { get; } } Setting EventArgsParameterPath to Item will extract the property value and pass it to the ICommand.Execute(object) method <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"MyNamespace.ContentPage\" xmlns:b=\"clr-namespace:Prism.Behaviors;assembly=Prism.Forms\"> <ListView> <ListView.Behaviors> <b:EventToCommandBehavior EventName=\"ItemTapped\" Command=\"{Binding ItemTappedCommand}\" EventArgsParameterPath=\"Item\" /> </ListView.Behaviors> </ListView> </ContentPage>"
  },
  "articles/Xamarin-Forms/5-Dependency-Service.html": {
    "href": "articles/Xamarin-Forms/5-Dependency-Service.html",
    "title": "Using the DependencyService with Prism | Prism",
    "keywords": "Using the DependencyService with Prism Xamarin.Forms includes a DependencyService to let shared code to easily resolve Interfaces to platform-specific implementations, allowing you to access features of the iOS, Android and Windows Phone SDKs from your PCL or Shared Project. The problem with Xamarin's DependencyService is that it requires a static call to DependencyService.Get<> in your shared code to get a platform-specific instance of the interface at run time. This makes your ViewModels less testable, and hides the dependencies of your class. Prism simplifies this feature by allowing you to simply request any dependencies that have been registered with Xamarin's DependencyService via your class constructor. public MainPageViewModel(ITextToSpeech textToSpeechService) { textToSpeechService.Speak(\"Hello World\"); } You can also gain access to Xamarin's DependencyService by using the IDependencyService interface. This interface removes the static call in your ViewModel, but still gives you access to Xamarin's DependencyService API. public MainPageViewModel(IDependencyService dependencyService) { dependencyService.Get<ITextToSpeech>().Speak(\"Hello World\"); } Example Step 1: Create Project Create a new Xamarin.Forms Portable or Shared project. Step 2: Add Prism Use NuGet to add Prism to each of your projects in the solution. Add the Following Nuget packages to your projects. Prism.Unity.Forms Prism.Forms Prism.Core Hint: If you add the Prism.Unity.Forms NuGet package first, it will bring in the other Prism packages automatically. Step 3: Add a Service In this examples, we will leverage the speech API of each platform to provide text to speech capabilities to our application. This means we need to create a service for each platform that will invoke that specific platform's speech API. This will require two steps: Add an interface to the Portable project that will define the contract for our speech service: public interface ITextToSpeech { void Speak(string text); } Add a class that implements our interface to each specific platform. Windows Phone public class TextToSpeech_WinPhone : ITextToSpeech { public async void Speak(string text) { SpeechSynthesizer synth = new SpeechSynthesizer(); await synth.SpeakTextAsync(text); } } Android public class TextToSpeech_Android : Object, ITextToSpeech, TextToSpeech.IOnInitListener { private TextToSpeech speaker; private string toSpeak; public void Speak(string text) { var c = Forms.Context; toSpeak = text; if (speaker == null) { speaker = new TextToSpeech(c, this); } else { var p = new Dictionary<string, string>(); speaker.Speak(toSpeak, QueueMode.Flush, p); Debug.WriteLine(\"spoke \" + toSpeak); } } #region IOnInitListener implementation public void OnInit(OperationResult status) { if (status.Equals(OperationResult.Success)) { Debug.WriteLine(\"speaker init\"); var p = new Dictionary<string, string>(); speaker.Speak(toSpeak, QueueMode.Flush, p); } else { Debug.WriteLine(\"was quiet\"); } } #endregion } iOS public class TextToSpeech_iOS : ITextToSpeech { public void Speak(string text) { var speechSynthesizer = new AVSpeechSynthesizer(); var speechUtterance = new AVSpeechUtterance(text) { Rate = AVSpeechUtterance.MaximumSpeechRate / 4, Voice = AVSpeechSynthesisVoice.FromLanguage(\"en-US\"), Volume = 0.5f, PitchMultiplier = 1.0f }; speechSynthesizer.SpeakUtterance(speechUtterance); } } Note: To Enable the speech capabilities on Windows Phone, tick the ID_CAP_SPEECH_RECOGNITION capability in the WMAppManifest.xml, otherwise access to the speech APIs are blocked. Step 4: Attribute the DependencyService Now, add the DependencyService attribute to each of the services classes in the respective platforms. This registers the platform specific implementation of the speech service with Xamarin.Forms' DependencyService. Windows Phone DependencyService [assembly: Dependency(typeof(TextToSpeech_WinPhone))] Android DependencyService [assembly: Dependency(typeof(TextToSpeech_Android))] iOS DependencyService [assembly: Dependency(typeof(TextToSpeech_iOS))] Step 5: Use the Speech Service Create the View Create a view that we can use to pass text to the speech service for the device to read back. This means we will need one Entry element to accept the text to speak, and one Button element to invoke a command in a ViewModel that will execute the speaking process from our speech service. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:mvvm=\"clr-namespace:Prism.Mvvm;assembly=Prism.Forms\" mvvm:ViewModelLocator.AutowireViewModel=\"True\" x:Class=\"UsingDependencyService.Views.MainPage\"> <StackLayout VerticalOptions=\"CenterAndExpand\" HorizontalOptions=\"CenterAndExpand\"> <Entry Text=\"{Binding TextToSay}\" VerticalOptions=\"Center\" HorizontalOptions=\"Center\" /> <Button Command=\"{Binding SpeakCommand}\" Text=\"Speak\"/> </StackLayout> </ContentPage> Create the ViewModel Create a ViewModel that has two properties that our View will bind to. We need a property to represent the text that we want to be spoken, and a command that the button in the View will invoke. public class MainPageViewModel : BindableBase { private string _textToSay = \"Hello from Xamarin.Forms and Prism\"; public string TextToSay { get { return _textToSay; } set { SetProperty(ref _textToSay, value); } } public DelegateCommand SpeakCommand { get; set; } public MainPageViewModel() { SpeakCommand = new DelegateCommand(Speak); } private void Speak() { //TODO: call service } } Use the Service Normally to use Xamarin.Forms DependencyService, you have to make a static method call in your ViewModel like this: private void Speak() { DependencyService.Get<ITextToSpeech>().Speak(TextToSay); } This is not good. You always want to avoid making calls to static methods in your ViewModela for a number of reasons. So how do we fix this? Easy! Let Prism do it for you. When you attribute a class with the Xamarin.Forms DependencyService attribute, Prism automatically registers that class with the container. This means you can now request the service via the ViewModel constructor as you do with your other dependencies. Modify the ViewModel to accept the service through the constructor. You will need to store this service instance in a variable so that it can be access in the Speak method. public class MainPageViewModel : BindableBase { private readonly ITextToSpeech _textToSpeech; private string _textToSay = \"Hello from Xamarin.Forms and Prism\"; public string TextToSay { get { return _textToSay; } set { SetProperty(ref _textToSay, value); } } public DelegateCommand SpeakCommand { get; set; } public MainPageViewModel(ITextToSpeech textToSpeech) { _textToSpeech = textToSpeech; SpeakCommand = new DelegateCommand(Speak); } private void Speak() { _textToSpeech.Speak(TextToSay); } } As you can see, you no longer need to make a call to the static Xamarin.Forms.DependencyService. Just ask for it in your ViewModel constructor, and Prism will use the container to resolve the instance and provide it to you. View the Sample"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Code Snippets | Prism",
    "keywords": "Code Snippets In-line [TestMethod] public void ThingGetsObjectValFromNumber() { Assert.AreEqual(42, new Thing().Get(42)); } Region public TestClass() { } Line Numbers public class TestClass { #region Snippet public TestClass() { } #endregion } Highlight namespace Documentation { public class TestClass { #region Snippet public TestClass() { } #endregion } } Link - not supported [!code-csharp[My Snippet](https://github.com/PrismLibrary/Prism/blob/master/Source/Xamarin/Prism.Forms/PrismApplicationBase.cs)] Warning/Tip/Important Note This is a note which needs your attention, but it's not super important. Tip This is a tip which needs your attention, but it's not super important. Warning This is a warning containing some important message. Important This is an important message. Caution This is an important message. Tabs not supported, but being added Video File Include Prism is a framework for building loosely coupled, maintainable, and testable XAML applications in WPF, Windows 10 UWP, and Xamarin Forms. Separate releases are available for each platform and those will be developed on independent timelines. Prism provides an implementation of a collection of design patterns that are helpful in writing well-structured and maintainable XAML applications, including MVVM, dependency injection, commands, EventAggregator, and others. Prism's core functionality is a shared code base in a Portable Class Library targeting these platforms. Those things that need to be platform specific are implemented in the respective libraries for the target platform. Prism also provides great integration of these patterns with the target platform. For example, Prism for UWP and Xamarin Forms allows you to use an abstraction for navigation that is unit testable, but that layers on top of the platform concepts and APIs for navigation so that you can fully leverage what the platform itself has to offer, but done in the MVVM way. Prism 6 is a fully open source version of the Prism guidance originally produced by Microsoft patterns & practices . The core team members were all part of the p&p team that developed Prism 1 through 5, and the effort has now been turned over to the open source community to keep it alive and thriving to support the .NET community. There are thousands of companies who have adopted previous versions of Prism for WPF, Silverlight, and Windows Runtime, and we hope they will continue to move along with us as we continue to evolve and enhance the framework to keep pace with current platform capabilities and requirements. At the current time we have no plans to create new versions of the library for Silverlight or for Windows 8/8.1/WP8.1. For those you can still use the previous releases from Microsoft p&p here and here . If there is enough interest and contributors to do the work, we can consider it, but it is not on our roadmap for now."
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | Prism",
    "keywords": "This is the HOMEPAGE . Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "articles/Xamarin-Forms/7-Working-With-TabbedPages.html": {
    "href": "articles/Xamarin-Forms/7-Working-With-TabbedPages.html",
    "title": "Working with TabbedPage's (or any MultiPage) | Prism",
    "keywords": "Working with TabbedPage's (or any MultiPage ) Initialization Currently Initialization largely left up to the developer to handle. Prism will pass NavigationParameters to the Selected Child page of a TabbedPage if included in Navigation Uri like NavigationService.NavigateAsync(\"MyTabbedPage/ViewA\") . However the other child pages will not have a chance to initialize with the NavigationParameters. There is a full example showing different techniques for handling View Initialization in the samples repo. public class ChildViewAModel : BindableBase, INavigatingAware { protected bool HasInitialized { get; set; } private string _message; public string Message { get { return _message; } set { SetProperty(ref _message, value); } } public void OnNavigatingTo(NavigationParameters parameters) { if(HasInitialized) return; HasInitialized = true; Message = parameters.GetValue<string>(\"message\"); } } You will notice in the example code that we checked the value for HasInitialzied and if it was true we simply return, otherwise we continue with our initialization logic. This will prevent any issues with double initialization as previously mentioned. To initialize the children we must implement INavigatingAware in our actual TabbedPage as follows: public partial class MyTabbedPage : TabbedPage, INavigatingAware { public MyTabbedPage() { InitializedComponent(); } public void OnNavigatingTo(NavigationParameters parameters) { foreach(var child in Children) { PageUtilities.OnNavigatingTo(child, parameters); } } } IActiveAware Prism Forms 6.3.0's introduction of Behaviors, also introduced the MutliPageActiveAwareBehavior , with an implementation for CarouselPage and TabbedPage . Each of these page types automatically get this behavior attached by the Navigation Service. This behavior will help you determine when to handle activation or deactivation events in the ViewModels of your Child Pages. The following code shows a possible way to handle a Child Page that will be initialized with NavigationParameters and then handle IActiveAware.IsActive . There is more than one way to do this, and this should not be taken as \"The way it has to be done\". It is also worth noting that the Behavior, will only set IsActive to true or false . While using the Event Handler is one possible implementation, you could just as easily bypass it's use. public abstract class ChildViewModelBase : BindableBase, IActiveAware, INavigatingAware, IDestructible { protected bool HasInitialized { get; set; } public event EventHandler IsActiveChanged; private bool _isActive; public bool IsActive { get { return _isActive; } set { SetProperty(ref _isActive, value, RaiseIsActiveChanged); } } public virtual void OnNavigatingTo(NavigationParameters parameters) { } public virtual void Destroy() { } protected virtual void RaiseIsActiveChanged() { IsActiveChanged?.Invoke(this, EventArgs.Empty); } } public class ChildViewA : ChildViewModelBase { public ChildViewA() { IsActiveChanged += HandleIsActiveTrue; IsActiveChanged += HandleIsActiveFalse; } public override void OnNavigatingTo(NavigationParameters parameters) { if(HasInitialized) return; HasInitialized = true; // Implement your implementation logic here... } private void HandleIsActiveTrue(object sender, EventArgs args) { if(IsActive == false) return; // Handle Logic Here } private void HandleIsActiveFalse(object sender, EventArgs args) { if(IsActive == true) return; // Handle Logic Here } public override void Destroy() { IsActiveChanged -= HandleIsActiveTrue; IsActiveChanged -= HandleIsActiveFalse; } }"
  },
  "articles/Xamarin-Forms/4-Page-Dialog-Service.html": {
    "href": "articles/Xamarin-Forms/4-Page-Dialog-Service.html",
    "title": "Using the Page Dialog Service | Prism",
    "keywords": "Using the Page Dialog Service Displaying an alert or asking a user to make a choice is a common UI task. Xamarin.Forms has two methods on the Page class for interacting with the user via a pop-up: DisplayAlert and DisplayActionSheet. Prism provides a single IPageDialogService that abstracts away the Xamarin.Forms Page object dependency required for these actions and keeps your ViewModels clean and testable. Simply request this service via the constructor of your ViewModel, and call either the DisplayAlert, or DisplayActionSheet to invoke the desired notification. public MainPageViewModel(IPageDialogService dialogService) { _dialogService = dialogService; } DisplayAlertAsync The DisplayAlertAsync method shows a modal pop-up to alert the user or ask simple questions of them. To display these alerts with Prism's IPageDialogService , use the DisplayAlertAsync method. The following line of code shows a simple message to the user: _dialogService.DisplayAlertAsync(\"Alert\", \"You have been alerted\", \"OK\"); This example does not collect information from the user. The alert displays modally and once dismissed the user continues interacting with the application. DisplayAlertAsync can also be used to capture a user's response by presenting two buttons and returning a boolean. To get a response from an alert, supply text for both buttons and await the method. After the user selects one of the options the answer will be returned to your code. Note the async and await keywords in the sample code below: var alertButton2 = new Button { Text = \"DisplayAlert Yes/No\" }; // triggers alert alertButton2.Clicked += async (sender, e) => { var answer = await DisplayAlertAsync (\"Question?\", \"Would you like to play a game\", \"Yes\", \"No\"); Debug.WriteLine(\"Answer: \" + answer); // writes true or false to the console }; DisplayActionSheetAsync The UIActionSheet is a common UI element in iOS. The IPageDialogService.DisplayActionSheetAsync lets you include this control in cross-platforms apps, rendering native alternatives in Android and Windows Phone. To display an action sheet, await DisplayActionSheetAsync in any ViewModel, passing the message and button labels as strings. The method returns the string label of the button that was clicked by the user. A simple example is shown here: var actionButton1 = new Button { Text = \"ActionSheet Simple\" }; actionButton1.Clicked += async (sender, e) => { var action = await DisplayActionSheetAsync (\"ActionSheet: Send to?\", \"Cancel\", null, \"Email\", \"Twitter\", \"Facebook\"); Debug.WriteLine(\"Action: \" + action); // writes the selected button label to the console }; The destroy button is rendered differently than the others, and can be left null or specified as the third string parameter. This example uses the destroy button: var actionButton2 = new Button { Text = \"ActionSheet\" }; actionButton2.Clicked += async (sender, e) => { var action = await DisplayActionSheetAsync (\"ActionSheet: Save Photo?\", \"Cancel\", \"Delete\", \"Photo Roll\", \"Email\"); Debug.WriteLine(\"Action: \" + action); // writes the selected button label to the console }; Additionally, Prism provides another option which accepts an array of IActionSheetButton that allow you to specificy the title of the buttons, as well as the DelegateCommand that should be executed when the option is selected by the user. This eliminates the need to capture a string result, perform a logical check against the result, and then execute a method or logic in response. To create an IActionSheetButton, use one of the three factory methods off of the ActionSheetButton class. ActionSheetButton.CreateButton ActionSheetButton.CreateCancelButton ActionSheetButton.CreateDestroyButton IActionSheetButton selectAAction = ActionSheetButton.CreateButton(\"Select A\", new DelegateCommand(() => { Debug.WriteLine(\"Select A\"); })); IActionSheetButton cancelAction = ActionSheetButton.CreateCancelButton(\"Cancel\", new DelegateCommand(() => { Debug.WriteLine(\"Cancel\"); })); IActionSheetButton destroyAction = ActionSheetButton.CreateDestroyButton(\"Destroy\", new DelegateCommand(() => { Debug.WriteLine(\"Destroy\"); })); void ShowActionSheet() { _pageDialogService.DisplayActionSheetAsync(\"My Action Sheet\", selectAAction, cancelAction, destroyAction); } Note: The order in which you pass in the IActionSheetButton parameters does not matter. The IPageDialogService will make sure the parameters are handled properly for you."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | Prism",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "README.html": {
    "href": "README.html",
    "title": "Prism-Documentation | Prism",
    "keywords": "Prism-Documentation"
  },
  "articles/Getting-Started/Download-and-Setup-Prism.html": {
    "href": "articles/Getting-Started/Download-and-Setup-Prism.html",
    "title": "Download and Setup Prism | Prism",
    "keywords": "Download and Setup Prism Learn what’s included in Prism including the documentation, code samples, and libraries. Additionally find out where to get the library and sample source code and the library NuGet packages. For a list of the new features, bug fixes, and API changes, see the release notes . Download and Setup the Prism Source Code This section describes how to install Prism. It involves the following three steps: Install system requirements. Download and extract the Prism source code and documentation. Compile and run the samples. Step 1: Install System Requirements Prism was designed to run on the Microsoft Windows 8 desktop, Microsoft Windows 7, Windows Vista, or Windows Server 2008 operating system. WPF applications built using this guidance require the .NET Framework 4.5. Before you can use the Prism Library, the following must be installed: Microsoft .NET Framework 4.5 or greater. Microsoft Visual Studio 2012 or greater. Xamarin for Visual Studio 3.11.1537 or greater. Step 2: Download and Extract the Prism Source Code and Documentation The easiest way to download Prism source code, and documentation is to fork the Prism repository . You can download the source code, documentation, and samples for the Prism library from the following links: Prism Source Code and Documentation Samples WPF Universal Windows Platform Xamarin.Forms Optionally you can add the Prism assemblies directly to your projects by using the NuGet packages . Step 3: Compile and Run Samples All samples use the Prism NuGet references so you can compile and run each solution directly. Adding Prism Library Source Projects to Solutions As part of shipping the Prism Library as NuGet packages, the Prism Library projects were removed from the solutions of all sample projects. If you are a developer accustomed to stepping through the Prism Library code as you build your application, there are a couple of options: Add the Prism Library Projects back in . To do this, right-click the solution, point to Add , and then click Existing project . Select the Prism Library projects. Then, to prevent inadvertently building these, click Configuration Manager on the Build menu, and then clear the Build check box for all Prism Library projects in both the debug and release configurations. Set a breakpoint and step in . Set a break point in your application's bootstrapper, and then step in to a method within the base class (F11 is the typical C# keyboard shortcut for this). You may be asked to locate the Prism Library source code, but often, the full program database (PDB) file is available and the file will simply open. You may set breakpoints in any Prism Library project by opening the file and setting the breakpoint."
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "| Prism",
    "keywords": "Prism is a framework for building loosely coupled, maintainable, and testable XAML applications in WPF, Windows 10 UWP, and Xamarin Forms. Separate releases are available for each platform and those will be developed on independent timelines. Prism provides an implementation of a collection of design patterns that are helpful in writing well-structured and maintainable XAML applications, including MVVM, dependency injection, commands, EventAggregator, and others. Prism's core functionality is a shared code base in a Portable Class Library targeting these platforms. Those things that need to be platform specific are implemented in the respective libraries for the target platform. Prism also provides great integration of these patterns with the target platform. For example, Prism for UWP and Xamarin Forms allows you to use an abstraction for navigation that is unit testable, but that layers on top of the platform concepts and APIs for navigation so that you can fully leverage what the platform itself has to offer, but done in the MVVM way. Prism 6 is a fully open source version of the Prism guidance originally produced by Microsoft patterns & practices . The core team members were all part of the p&p team that developed Prism 1 through 5, and the effort has now been turned over to the open source community to keep it alive and thriving to support the .NET community. There are thousands of companies who have adopted previous versions of Prism for WPF, Silverlight, and Windows Runtime, and we hope they will continue to move along with us as we continue to evolve and enhance the framework to keep pace with current platform capabilities and requirements. At the current time we have no plans to create new versions of the library for Silverlight or for Windows 8/8.1/WP8.1. For those you can still use the previous releases from Microsoft p&p here and here . If there is enough interest and contributors to do the work, we can consider it, but it is not on our roadmap for now."
  }
}